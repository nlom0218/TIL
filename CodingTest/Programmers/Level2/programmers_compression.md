# [3차] 압축

## 1. 개요

- 프로그래머스
- Lv.2
- 2018 KAKAO BLIND RECRUITMENT
- [문제 바로가기](https://school.programmers.co.kr/learn/courses/30/lessons/17684)

---

## 2. 문제 설명

신입사원 어피치는 카카오톡으로 전송되는 메시지를 압축하여 전송 효율을 높이는 업무를 맡게 되었다. 메시지를 압축하더라도 전달되는 정보가 바뀌어서는 안 되므로, 압축 전의 정보를 완벽하게 복원 가능한 무손실 압축 알고리즘을 구현하기로 했다.

어피치는 여러 압축 알고리즘 중에서 성능이 좋고 구현이 간단한 LZW(Lempel–Ziv–Welch) 압축을 구현하기로 했다. LZW 압축은 1983년 발표된 알고리즘으로, 이미지 파일 포맷인 GIF 등 다양한 응용에서 사용되었다.

LZW 압축은 다음 과정을 거친다.

1. 길이가 1인 모든 단어를 포함하도록 사전을 초기화한다.
2. 사전에서 현재 입력과 일치하는 가장 긴 문자열 w를 찾는다.
3. w에 해당하는 사전의 색인 번호를 출력하고, 입력에서 w를 제거한다.
4. 입력에서 처리되지 않은 다음 글자가 남아있다면(c), w+c에 해당하는 단어를 사전에 등록한다.
5. 단계 2로 돌아간다.

압축 알고리즘이 영문 대문자만 처리한다고 할 때, 사전은 다음과 같이 초기화된다. 사전의 색인 번호는 정수값으로 주어지며, 1부터 시작한다고 하자.

| 색인 번호 | 1   | 2   | 3   | ... | 24  | 25  | 26  |
| --------- | --- | --- | --- | --- | --- | --- | --- |
| 단어      | A   | B   | C   | ... | X   | Y   | Z   |

예를 들어 입력으로 KAKAO가 들어온다고 하자.

1. 현재 사전에는 KAKAO의 첫 글자 K는 등록되어 있으나, 두 번째 글자까지인 KA는 없으므로, 첫 글자 K에 해당하는 색인 번호 11을 출력하고, 다음 글자인 A를 포함한 KA를 사전에 27 번째로 등록한다.
2. 두 번째 글자 A는 사전에 있으나, 세 번째 글자까지인 AK는 사전에 없으므로, A의 색인 번호 1을 출력하고, AK를 사전에 28 번째로 등록한다.
3. 세 번째 글자에서 시작하는 KA가 사전에 있으므로, KA에 해당하는 색인 번호 27을 출력하고, 다음 글자 O를 포함한 KAO를 29 번째로 등록한다.
4. 마지막으로 처리되지 않은 글자 O에 해당하는 색인 번호 15를 출력한다.

|현재 입력(w) |다음 글자(c)| 출력 |사전 추가(w+c)|
|K |A| 11| 27: KA|
|---|---|---|---|
|A |K |1 |28: AK|
|KA |O| 27 |29: KAO|
|O | |15 |

이 과정을 거쳐 다섯 글자의 문장 KAKAO가 4개의 색인 번호 [11, 1, 27, 15]로 압축된다.

입력으로 TOBEORNOTTOBEORTOBEORNOT가 들어오면 다음과 같이 압축이 진행된다.

| 현재 입력(w) | 다음 글자(c) | 출력 | 사전 추가(w+c) |
| ------------ | ------------ | ---- | -------------- |
| T            | O            | 20   | 27: TO         |
| O            | B            | 15   | 28: OB         |
| B            | E            | 2    | 29: BE         |
| E            | O            | 5    | 30: EO         |
| O            | R            | 15   | 31: OR         |
| R            | N            | 18   | 32: RN         |
| N            | O            | 14   | 33: NO         |
| O            | T            | 15   | 34: OT         |
| T            | T            | 20   | 35: TT         |
| TO           | B            | 27   | 36: TOB        |
| BE           | O            | 29   | 37: BEO        |
| OR           | T            | 31   | 38: ORT        |
| TOB          | E            | 36   | 39: TOBE       |
| EO           | R            | 30   | 40: EOR        |
| RN           | O            | 32   | 41: RNO        |
| OT           |              | 34   |

### 2-1. 문제 설명 - 입력 형식

입력으로 영문 대문자로만 이뤄진 문자열 msg가 주어진다. msg의 길이는 1 글자 이상, 1000 글자 이하이다.

### 2-2. 문제 설명 - 출력 형식

주어진 문자열을 압축한 후의 사전 색인 번호를 배열로 출력하라.

### 2-3. 문제 설명 - 입출력 예제

| msg                      | answer                                                         |
| ------------------------ | -------------------------------------------------------------- |
| KAKAO                    | [11, 1, 27, 15]                                                |
| TOBEORNOTTOBEORTOBEORNOT | [20, 15, 2, 5, 15, 18, 14, 15, 20, 27, 29, 31, 36, 30, 32, 34] |
| ABABABABABABABAB         | [1, 2, 27, 29, 28, 31, 30]                                     |

---

## 3. 문제 풀이

```javascript
const dic = {
  A: 1,
  B: 2,
  C: 3,
  D: 4,
  E: 5,
  F: 6,
  G: 7,
  H: 8,
  I: 9,
  J: 10,
  K: 11,
  L: 12,
  M: 13,
  N: 14,
  O: 15,
  P: 16,
  Q: 17,
  R: 18,
  S: 19,
  T: 20,
  U: 21,
  V: 22,
  W: 23,
  X: 24,
  Y: 25,
  Z: 26,
  length: 26,
};

function solution(msg) {
  let answer = [];
  let count = 1;
  while (true) {
    // 1) 0번째 부터 count까지의 문자가 사전에 있다면 count를 1 올린다.
    if (dic[msg.slice(0, count)]) count += 1;
    else {
      // 2) 색인 번호가 담긴 사전에 새로운 문자열와 이에 해당하는 색인 번호를 추가한다.
      dic[msg.slice(0, count)] = dic.length + 1;
      dic.length += 1;

      // 3) 사전에 새롭게 추가된 문자열에서 마지막 문자만 지운 문자열의 색인 번호를 answer 배열에 추가한다.
      answer.push(dic[msg.slice(0, count - 1)]);
      msg = msg.slice(count - 1);
      count = 1;
    }

    // 4) count가 msg의 길이보다 클 때, 즉 더 이상 참고할 문자가 없을 때 남은 문자열의 색인 번호를 answer 배열에 추가한 뒤 반환한다.
    if (count > msg.length) {
      answer.push(dic[msg.slice(0, count - 1)]);
      return answer;
    }
  }
}
```

초기 색인 번호가 담긴 사전은 `dic` 객체로 만든다. 또한 특정 조건이 만족할 때 까지 반복문을 실행한다.

### 1) 0번째 부터 count까지의 문자가 사전에 있다면 count를 1 올린다.

```javascript
if (dic[msg.slice(0, count)]) count += 1;
```

`msg`의 첫 번째 문자부터 `count` 이전의 문자가 `dic`에 등록되어 있으면 `count`를 1 올린다. `count`를 1 올리는 것은 기존 문자에 하나의 문자를 더 붙여 `dic`에 등록되어 있는지 확인하는 과정을 위한 것이다.

예를 들어 `KA`가 `dic`에 등록되어 있으면 `KAK`도 `dic`에 등록되어 있는지 확인한다.

### 2) 색인 번호가 담긴 사전에 새로운 문자열와 이에 해당하는 색인 번호를 추가한다.

```javascript
dic[msg.slice(0, count)] = dic.length + 1;
dic.length += 1;
```

위는 어떠한 문자열가 `dic`에 등록되지 않았을 때 실행되는 첫 번째 과정이다. 해당 과정에서 어떠한 문자열를 `dic`에 새롭게 등록한다.

`dic`의 `length` 값보다 1 큰 값을 색인 번호로 정한 후 `length` 속성을 1 증가시킨다.

### 3) 사전에 새롭게 추가된 문자열에서 마지막 문자만 지운 문자열의 색인 번호를 answer 배열에 추가한다.

```javascript
answer.push(dic[msg.slice(0, count - 1)]);
msg = msg.slice(count - 1);
count = 1;
```

위는 어떠한 문자열가 `dic`에 등록되지 않았을 때 실행되는 두 번째 과정이다. 바로 전 과정에서 `dic`에 새로운 문자열와 색인 번호를 등록하였으니

1. 반환해야 하는 `answer` 배열에 새롭게 등록된 문자열에서 마지막 문자를 제거한 문자열의 색인 번호를 추가한다.
2. `answer` 배열에 추가하 문자열을 제외한 문자열을 `msg`에 재할당 한다.
3. `count`를 1로 초기화한다.

### 4) count가 msg의 길이보다 클 때, 즉 더 이상 참고할 문자가 없을 때 남은 문자열의 색인 번호를 answer 배열에 추가한 뒤 반환한다.

```javascript
if (count > msg.length) {
  answer.push(dic[msg.slice(0, count - 1)]);
  return answer;
}
```

반복문이 종료되는 조건이다. `count`가 계속 증가를 하다 결국 `msg`의 길이보다 커지게 되면 더 이상 참고할 문자가 없다는 것이다. 때문에 이때 반복문을 종료해야 한다.

종료하는 동시에 남은 문자열의 색인 번호를 `answer` 배열에 추가한 뒤 `answer` 배열을 반환한다.

### 결과

![programmers_compression_result](/image/CodingTest/programmers_compression/programmers_compression_result.png)

---

## 4. Conclusion

> Level 2단계의 카카오 기출 문제이다. 조건만 잘 생각하여 코드를 작성하면 쉽게 풀 수 있는 문제라고 생각한다. 복잡한 것은 크게 없었으나 색인 번호를 배열을 담을 때 `slice` 메서드의 동작을 정확히 알고 있어야 오류 없이 테스트를 통과할 수 있다. `slice` 메서드의 두 번재 인자는 숫자이며 인덱스를 뜻한다. 하지만 해당 인덱스의 요소는 해당되지 않고 바로 앞의 인덱스까지만 자르는 것이므로 이를 주의하도록 하자.  
> 이러한 문제는 보통 난 `Map 객체`를 사용하여 푼다. 하지만 이번엔 일반 객체를 만들고 `length` 라는 프로퍼티도 추가하여 마치 `Map 객체`처럼 사용하였다. 무엇이 더 좋은 방법일까 궁금하다. 둘다 유용하지만 많이들 사용하는 방법이 무엇인지? 더 효율적이고 가독성이 좋은 방법은 무엇인지 궁금하다. 나중에 우테코 크루들과 비슷한 유형의 문제를 공부하게 되면 알아보자.

---

📅 2023-01-24
